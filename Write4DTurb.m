% Write out 4D turbulence into binary file
% turbulence generator or Turbsim
% 
% Usage: Write4DTurb(ConfigParameters,TurbData4D)
% 
% 
% Input: Configuration parameters, TurbData4D generated by 'Generate4DTurb.m'
% 
% 
% 
% Output: [ErrorSat, ErrorMessage]
%         ErrorSat: 1 for error detected, 0 for no error
%         ErrorMessage: the error message, written as string
%         also a binary file written to the 'TurbResults' folder
% 
% 
% Modified:
% 
% 
% ToDo: 
% 
% Created: Feng Guo 19-Nov 2020 Flensburg University of Applied Sciences

function  [ErrorSat, ErrorMessage] = Write4DTurb(ConfigParameters,TurbData4D)

% Model Specific lines used for Turbsim
if ConfigParameters.Model == 'Kaimal'
    Xvec                            = ConfigParameters.Xvec;
    Nlongi                          = ConfigParameters.Nlongi;
    Nx                              = ConfigParameters.Nx ;
    Ny                              = ConfigParameters.Ny ;
    Nz                              = ConfigParameters.Nz ;
    Seeds                           = ConfigParameters.Seeds ;
    SimulationName4D                = ConfigParameters.SimulationName4D;
    Scale                           = ConfigParameters.Scale;
    Offset                          = ConfigParameters.Offset;    
    ubin                            = int16((TurbData4D.u-Offset(1))./Scale(1));
    vbin                            = int16((TurbData4D.v-Offset(2))./Scale(2));
    wbin                            = int16((TurbData4D.w-Offset(3))./Scale(3));


    
    fid = fopen([ConfigParameters.saveDir '\' ConfigParameters.SimulationName4D '.evo'], 'w' );
    
    fwrite(fid,int16(length(Xvec)-1),'int16')  ; % write the head line with Nlongi the number of unfrozen planes
    fwrite(fid,int16(Xvec(2:end)),'int16') ;       % write the x positions of unfrozen planes
    
    Size   =  size(TurbData4D.u);
    uvw    =  zeros(3,Size(1)-1,Size(2),Size(3),Size(4));
    uvw(1,:,:,:,:) = ubin(2:end,:,:,:);
    uvw(2,:,:,:,:) = vbin(2:end,:,:,:);
    uvw(3,:,:,:,:) = wbin(2:end,:,:,:);
    
    uvw = permute(uvw,[1 4 5 3 2]);   % change the index sequence for easier read in Fortran
    
    uvw_ori =  zeros(3,Size(1)-1,Size(2),Size(3),Size(4)); 
    uvw_ori(1,:,:,:,:) = TurbData4D.u(2:end,:,:,:);
    uvw_ori(2,:,:,:,:) = TurbData4D.v(2:end,:,:,:);
    uvw_ori(3,:,:,:,:) = TurbData4D.w(2:end,:,:,:);
    
    uvw_ori = permute(uvw_ori,[1 4 5 3 2]);   % change the index sequence for easier read in Fortran
    
    
    disp('Writting out binary file...')
    fwrite(fid,uvw(:),'int16');


        
    fclose('all');
    disp('Binary file wrote out!')
   
    ErrorSat     = 0 ;
    ErrorMessage = 'No error detected!';
        
        
    % Model Specific lines used for Mann turbulengthce generator
elseif ConfigParameters.Model == 'Mann' %baustelle
    %         Xvec                            = np.array(ConfigParameters.Xvec).reshape(length(ConfigParameters.Xvec),1)
    %         Nx                              = ConfigParameters.Nx
    %         Ny                              = ConfigParameters.Ny
    %         Nz                              = ConfigParameters.Nz
    %         X1                              = np.concatenate((Xvec,0*Xvec),axis=1)
    %         X2                              = np.concatenate((Xvec,0*Xvec),axis=1)
    %         rx                              = cdist(X1, X2)
    %         nfft                            = Nx;
    %         Seeds                           = ConfigParameters.Seeds
    %         u                               = TurbData3D.u
    %         w                               = TurbData3D.w
    %         kappa_x                         = ConfigParameters.kappa_x
    %
    %
    %         # specify the variable
    %         TurbData4D                      = {}
    %         TurbData4D.u                 = np.zeros((length(Seeds),Nx,Ny,Nz))  #  4d turb
    %         TurbData4D.v                 = TurbData3D.v
    %         TurbData4D.w                 = np.zeros((length(Seeds),Nx,Ny,Nz))  #  4d turb
    %
    %         #  Calculate fourier coeffieients
    %         FCu                             = np.zeros((length(Seeds),Nx,Ny*Nz),dtype=np.complex_)  # two sided Fourier coefficient u
    %         FCw                             = np.zeros((length(Seeds),Nx,Ny*Nz),dtype=np.complex_)  # two sided Fourier coefficient w
    %
    %         Hu_yz                           = np.zeros((length(Seeds),int(Nx/2)),dtype=np.complex_)      # single sided FC
    %         Hw_yz                           = np.zeros((length(Seeds),int(Nx/2)),dtype=np.complex_)      # single sided FC
    %
    %         H_u_new                         = np.zeros((length(Seeds),int(Nx/2)),dtype=np.complex_)      # single sided FC unfrozen
    %         H_w_new                         = np.zeros((length(Seeds),int(Nx/2)),dtype=np.complex_)      # single sided FC unfrozen
    %
    %         u_unfro                         = np.zeros((length(Seeds),Nx,Ny*Nz))  # temporarily store the unfrozen u
    %         w_unfro                         = np.zeros((length(Seeds),Nx,Ny*Nz))  # temporarily store the unfrozen w
    %
    %         for i =1: lengthgth(Seeds)
    %             FCu[i]                      = np.fft.fft(u[i], axis=0).reshape(Nx,Ny*Nz, order="F")
    %             FCw[i]                      = np.fft.fft(w[i], axis=0).reshape(Nx,Ny*Nz, order="F")
    %
    %             disp('Turbulengthce unfreezing started...')
    %
    %             for i_yz = 1: Ny*Nz      % loop over points inside yz plane
    %
    %                 for i_x in range(length(Seeds)):  # loop over differnt yz planes
    %                     Hu_yz[i_x,:]              = FCu[i_x,1:int(Nx/2)+1,i_yz]
    %                     Hw_yz[i_x,:]              = FCw[i_x,1:int(Nx/2)+1,i_yz]
    %                 end
    %
    %                 for i_f =1:nfft/2  % loop over each frequency
    %                     gamma_u_x           = np.exp(-kappa_x[i_f]*rx) ;       % Coherence matrix X plane;
    %                     Gcohx               = np.linalg.cholesky(gamma_u_x) ;  % cholesky decomposition of X  coherence
    %                     H_u_new[:,i_f]      = Gcohx.dot(Hu_yz[:,i_f]);
    %                     H_w_new[:,i_f]      = Gcohx.dot(Hw_yz[:,i_f]);
    %                     u_unfro[:,:,i_yz]   = np.real(ifftr(H_u_new))
    %                     w_unfro[:,:,i_yz]   = np.real(ifftr(H_w_new))
    %
    %                 end
    %             end
    %         end
    %         % the TurbData is stored by the dimention Nlongi*3(uvw) *Nx*Ny*Nz
    %         TurbData4D.u         = u_unfro.reshape(length(ConfigParameters.Xvec),Nx,Ny,Nz) ;
    %         TurbData4D.w         = w_unfro.reshape(length(ConfigParameters.Xvec),Nx,Ny,Nz) ;
    %         print('4D turbulengthce simulation finished!')
    %         ErrorSat     = 0 ;
    %         ErrorMessage = 'No error detected!';
    
    
else
    ErrorSat = 1 ;
    ErrorMessage = 'Turbulence model undefined!';
    error(ErrorMessage)
end


end






